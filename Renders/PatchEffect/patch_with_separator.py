#!/usr/bin/env python3
"""
Patch with Separator Visualization using BlenderToolbox

Renders a mesh with:
1. Vertices colored by their patch assignments (vertex colors)
2. Separator vertices colored dark (as lines/bands on the mesh)

Combines functionality from:
- render_patch.py (patch coloring via vertex colors)
- show_separator_as_color.py (separator coloring via vertex colors)

Requires:
    - pip install bpy==4.3.0 --extra-index-url https://download.blender.org/pypi/
    - pip install blendertoolbox

Data files (generated by gen_sep_data.cpp):
    - {mesh}_vertex_to_patch_patches{N}.txt - patch ID per vertex
    - PATCH_ORDERING_etree_nodes_{mesh}_patches{N}.txt - etree node IDs
    - PATCH_ORDERING_assigned_nodes_{mesh}_patches{N}.txt - original vertex indices

Usage:
    python patch_with_separator.py --mesh /path/to/mesh.obj --num_patches 8
    python patch_with_separator.py --mesh /path/to/mesh.obj --num_patches 16 --max_level 1
    python patch_with_separator.py --help
"""

import bpy
import os
import sys
import argparse
import math
from collections import defaultdict
import blendertoolbox as bt


def parse_args():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description='Render mesh with patch colors and separator lines')
    parser.add_argument('--mesh', type=str,
                        default='/media/behrooz/FarazHard/Last_Project/BenchmarkMesh/tri-mesh/final/beetle.obj',
                        help='Path to the mesh file (OBJ, PLY, etc.)')
    parser.add_argument('--patch_data', type=str, default=None,
                        help='Path to vertex-to-patch mapping file')
    parser.add_argument('--etree', type=str, default=None,
                        help='Path to PATCH_ORDERING_etree_nodes file')
    parser.add_argument('--assigned', type=str, default=None,
                        help='Path to PATCH_ORDERING_assigned_nodes file')
    parser.add_argument('--output', type=str, default=None,
                        help='Output image path')
    parser.add_argument('--num_patches', type=int, default=8,
                        help='Number of patches (for auto-generating file paths)')
    parser.add_argument('--max_level', type=int, default=0,
                        help='Maximum separator level (0=root only, 1=root+level1, etc.)')
    parser.add_argument('--resolution', type=int, default=2048,
                        help='Output resolution (square)')
    parser.add_argument('--samples', type=int, default=500,
                        help='Number of render samples')
    parser.add_argument('--subdivision', type=int, default=1,
                        help='Subdivision level for smoother surface (0=none, 1=light, 2=smooth)')
    return parser.parse_args()


# High-contrast colors for patches (from render_patch.py)
PATCH_COLORS = [
    (0.122, 0.467, 0.706, 1.0),  # Strong blue
    (1.000, 0.498, 0.055, 1.0),  # Bright orange
    (0.173, 0.627, 0.173, 1.0),  # Forest green
    (0.839, 0.153, 0.157, 1.0),  # Crimson red
    (0.580, 0.404, 0.741, 1.0),  # Rich purple
    (0.549, 0.337, 0.294, 1.0),  # Brown
    (0.890, 0.467, 0.761, 1.0),  # Hot pink
    (0.498, 0.498, 0.498, 1.0),  # Medium gray
    (0.737, 0.741, 0.133, 1.0),  # Olive yellow
    (0.090, 0.745, 0.812, 1.0),  # Cyan
    (0.682, 0.780, 0.910, 1.0),  # Steel blue
]

# Separator color (dark, appears as lines between patches)
SEPARATOR_COLOR = (0.08, 0.08, 0.08, 1.0)  # Near-black


# ============================================================================
# Data Loading Functions
# ============================================================================

def load_patch_ids(filepath):
    """Load patch IDs from file (one integer per line)."""
    with open(filepath, 'r') as f:
        return [int(line.strip()) for line in f if line.strip()]


def load_file_as_ints(filepath):
    """Load a file with one integer per line."""
    with open(filepath, 'r') as f:
        return [int(line.strip()) for line in f if line.strip()]


# ============================================================================
# Separator Functions
# ============================================================================

def get_separator_vertices(etree_nodes, assigned_nodes, max_level):
    """
    Get separator vertex indices for the given level.
    
    Args:
        etree_nodes: List of etree node IDs for each position
        assigned_nodes: List of original vertex indices for each position
        max_level: Maximum separator level
    
    Returns:
        Set of original vertex indices that are separators
    
    Level 0: etree == 0
    Level 1: etree in {0, 1, 2}
    Level N: etree in range [0, 2^(N+1) - 2]
    """
    max_etree_id = (1 << (max_level + 1)) - 2  # 2^(max_level+1) - 2
    
    separator_verts = set()
    for etree_id, orig_vertex in zip(etree_nodes, assigned_nodes):
        if etree_id <= max_etree_id:
            separator_verts.add(orig_vertex)
    
    return separator_verts


# ============================================================================
# Vertex Coloring Functions
# ============================================================================

def apply_patch_and_separator_colors(mesh_obj, patch_ids, separator_verts):
    """
    Apply vertex colors based on patch assignments and separator status.
    
    - Separator vertices get dark color (appears as lines)
    - Non-separator vertices get their patch color
    
    Args:
        mesh_obj: Blender mesh object
        patch_ids: List of patch IDs (index i = patch ID for vertex i)
        separator_verts: Set of vertex indices that are separators
    
    Returns:
        Dictionary with patch statistics
    """
    mesh_data = mesh_obj.data
    
    # Remove existing color attribute if present
    if "PatchColors" in mesh_data.color_attributes:
        mesh_data.color_attributes.remove(mesh_data.color_attributes["PatchColors"])
    
    # Create new color attribute with CORNER domain (per loop vertex)
    color_layer = mesh_data.color_attributes.new(
        name="PatchColors",
        type='FLOAT_COLOR',
        domain='CORNER'
    )
    
    # Count patches
    patch_counts = {}
    num_vertices = len(mesh_data.vertices)
    num_separators = 0
    
    # Verify patch_ids length matches vertices
    if len(patch_ids) != num_vertices:
        print(f"Warning: patch_ids length ({len(patch_ids)}) != mesh vertices ({num_vertices})")
        print(f"Using min of both: {min(len(patch_ids), num_vertices)}")
    
    # Build vertex color mapping
    vertex_colors = {}
    for i in range(min(len(patch_ids), num_vertices)):
        if i in separator_verts:
            # Separator vertex -> dark color
            vertex_colors[i] = SEPARATOR_COLOR
            num_separators += 1
        else:
            # Non-separator vertex -> patch color
            patch_id = patch_ids[i]
            color = PATCH_COLORS[patch_id % len(PATCH_COLORS)]
            vertex_colors[i] = color
            patch_counts[patch_id] = patch_counts.get(patch_id, 0) + 1
    
    # Assign colors to each loop (face corner)
    for poly in mesh_data.polygons:
        for loop_idx in poly.loop_indices:
            vert_idx = mesh_data.loops[loop_idx].vertex_index
            color = vertex_colors.get(vert_idx, PATCH_COLORS[0])
            color_layer.data[loop_idx].color = color
    
    print(f"Applied colors: {num_separators} separator vertices (dark), "
          f"{num_vertices - num_separators} patch vertices")
    
    return patch_counts


def create_vertex_color_material(mesh_obj):
    """
    Create an opaque Principled BSDF material that reads vertex colors.
    """
    mat = bpy.data.materials.new(name="PatchSeparatorMaterial")
    mat.use_nodes = True
    
    # Ensure opaque render settings
    if hasattr(mat, "blend_method"):
        mat.blend_method = 'OPAQUE'
    if hasattr(mat, "shadow_method"):
        mat.shadow_method = 'OPAQUE'
    
    nodes = mat.node_tree.nodes
    links = mat.node_tree.links
    nodes.clear()
    
    # Output node
    output = nodes.new(type='ShaderNodeOutputMaterial')
    output.location = (400, 0)
    
    # Principled BSDF with good visual settings
    principled = nodes.new(type='ShaderNodeBsdfPrincipled')
    principled.location = (100, 0)
    
    # Set material properties for nice soft appearance
    if 'Roughness' in principled.inputs:
        principled.inputs['Roughness'].default_value = 0.45
    if 'Metallic' in principled.inputs:
        principled.inputs['Metallic'].default_value = 0.0
    if 'Alpha' in principled.inputs:
        principled.inputs['Alpha'].default_value = 1.0
    if 'Specular IOR Level' in principled.inputs:
        principled.inputs['Specular IOR Level'].default_value = 0.25
    
    # Attribute node to read vertex colors
    attr_node = nodes.new(type='ShaderNodeAttribute')
    attr_node.location = (-200, 0)
    attr_node.attribute_name = "PatchColors"
    attr_node.attribute_type = 'GEOMETRY'
    
    # Connect: VertexColor -> Base Color -> Output
    links.new(attr_node.outputs['Color'], principled.inputs['Base Color'])
    links.new(principled.outputs['BSDF'], output.inputs['Surface'])
    
    # Assign material to mesh
    if mesh_obj.data.materials:
        mesh_obj.data.materials[0] = mat
    else:
        mesh_obj.data.materials.append(mat)
    
    return mat


# ============================================================================
# Main Rendering Function
# ============================================================================

def render_patch_with_separator(mesh_path, patch_data_path, etree_path, assigned_path,
                                 output_path, max_level=0,
                                 resolution=2048, samples=500, subdivision=1):
    """
    Main rendering function combining patch colors and separator lines.
    
    Args:
        mesh_path: Path to mesh file
        patch_data_path: Path to vertex-to-patch mapping file
        etree_path: Path to etree_nodes file
        assigned_path: Path to assigned_nodes file
        output_path: Output image path
        max_level: Maximum separator level to display
        resolution: Output resolution (square)
        samples: Render samples
        subdivision: Subdivision level (0-2)
    """
    # Initialize Blender
    bt.blenderInit(resolution, resolution, samples, 1.5)
    
    # Load mesh with same transforms as other render scripts
    location = (0, 0.09, 0.68)
    mesh_scale = (1, 1, 1)
    rotation = (0, 0, 0)
    mesh = bt.readMesh(mesh_path, location, rotation, mesh_scale)
    
    # Smooth shading
    bpy.ops.object.shade_smooth()
    
    # ========================================================================
    # Step 1: Load data
    # ========================================================================
    print(f"Loading patch data from: {patch_data_path}")
    patch_ids = load_patch_ids(patch_data_path)
    print(f"Loaded {len(patch_ids)} patch assignments")
    
    print(f"\nLoading separator data...")
    print(f"  Etree nodes: {etree_path}")
    print(f"  Assigned nodes: {assigned_path}")
    
    etree_nodes = load_file_as_ints(etree_path)
    assigned_nodes = load_file_as_ints(assigned_path)
    
    if len(etree_nodes) != len(assigned_nodes):
        print(f"Warning: File length mismatch! etree_nodes: {len(etree_nodes)}, "
              f"assigned_nodes: {len(assigned_nodes)}")
    
    print(f"Loaded {len(etree_nodes)} etree nodes and {len(assigned_nodes)} assigned nodes")
    
    # ========================================================================
    # Step 2: Get separator vertices
    # ========================================================================
    separator_verts = get_separator_vertices(etree_nodes, assigned_nodes, max_level)
    print(f"Found {len(separator_verts)} separator vertices at max_level={max_level}")
    
    # ========================================================================
    # Step 3: Apply vertex colors (patches + separators)
    # ========================================================================
    patch_counts = apply_patch_and_separator_colors(mesh, patch_ids, separator_verts)
    print(f"\nPatch distribution:")
    for pid in sorted(patch_counts.keys()):
        print(f"  Patch {pid}: {patch_counts[pid]} vertices")
    
    # Apply subdivision for smoother surface (before material)
    if subdivision > 0:
        bt.subdivision(mesh, level=subdivision)
    
    # Create and apply vertex color material
    create_vertex_color_material(mesh)
    
    # ========================================================================
    # Step 4: Setup scene and render
    # ========================================================================
    bt.invisibleGround(shadowBrightness=0.9)
    
    # Set camera
    camLocation = (3, 0, 2)
    lookAtLocation = (0, 0, 0.5)
    focalLength = 45
    cam = bt.setCamera(camLocation, lookAtLocation, focalLength)
    
    # Set sun light
    lightAngle = (6, -30, -155)
    strength = 2
    shadowSoftness = 0.3
    bt.setLight_sun(lightAngle, strength, shadowSoftness)
    
    # Set ambient light
    bt.setLight_ambient(color=(0.1, 0.1, 0.1, 1))
    
    # Set shadow threshold for clean shadows
    bt.shadowThreshold(alphaThreshold=0.05, interpolationMode='CARDINAL')
    
    # Create output directory if needed
    output_dir = os.path.dirname(output_path)
    if output_dir and not os.path.exists(output_dir):
        os.makedirs(output_dir, exist_ok=True)
    
    # Save .blend file alongside the image
    blend_path = os.path.splitext(output_path)[0] + '.blend'
    bpy.ops.wm.save_mainfile(filepath=blend_path)
    print(f"\nSaved Blender file: {blend_path}")
    
    # Render image
    bt.renderImage(output_path, cam)
    print(f"Rendered image: {output_path}")


def main():
    args = parse_args()
    
    # Validate mesh path
    if not os.path.exists(args.mesh):
        print(f"Error: Mesh file not found: {args.mesh}")
        sys.exit(1)
    
    # Generate default file paths based on mesh name and num_patches
    script_dir = os.path.dirname(os.path.abspath(__file__))
    mesh_name = os.path.splitext(os.path.basename(args.mesh))[0]
    patch_suffix = f"_patches{args.num_patches}"
    
    # Default paths for data files
    render_data_dir = os.path.join(script_dir, '..', '..', 'output', 'render_data')
    
    if args.patch_data is None:
        args.patch_data = os.path.join(
            render_data_dir,
            f'{mesh_name}_vertex_to_patch{patch_suffix}.txt'
        )
    
    if args.etree is None:
        args.etree = os.path.join(
            render_data_dir,
            f'PATCH_ORDERING_etree_nodes_{mesh_name}{patch_suffix}.txt'
        )
    
    if args.assigned is None:
        args.assigned = os.path.join(
            render_data_dir,
            f'PATCH_ORDERING_assigned_nodes_{mesh_name}{patch_suffix}.txt'
        )
    
    # Validate data files exist
    for name, path in [('Patch data', args.patch_data),
                       ('Etree nodes', args.etree),
                       ('Assigned nodes', args.assigned)]:
        if not os.path.exists(path):
            print(f"Error: {name} file not found: {path}")
            sys.exit(1)
    
    # Generate output path if not specified
    if args.output is None:
        figures_dir = os.path.join(script_dir, 'Figures')
        args.output = os.path.join(
            figures_dir,
            f'{mesh_name}_patch_sep_{args.num_patches}_level{args.max_level}.png'
        )
    
    print("=" * 70)
    print("Patch with Separator Visualization")
    print("=" * 70)
    print(f"Mesh:              {args.mesh}")
    print(f"Patch Data:        {args.patch_data}")
    print(f"Etree Nodes:       {args.etree}")
    print(f"Assigned Nodes:    {args.assigned}")
    print(f"Output:            {args.output}")
    print(f"Num Patches:       {args.num_patches}")
    print(f"Max Level:         {args.max_level}")
    print(f"Resolution:        {args.resolution}x{args.resolution}")
    print(f"Samples:           {args.samples}")
    print(f"Subdivision:       {args.subdivision}")
    print("=" * 70)
    
    render_patch_with_separator(
        mesh_path=args.mesh,
        patch_data_path=args.patch_data,
        etree_path=args.etree,
        assigned_path=args.assigned,
        output_path=args.output,
        max_level=args.max_level,
        resolution=args.resolution,
        samples=args.samples,
        subdivision=args.subdivision
    )
    
    print("\nDone!")


if __name__ == "__main__":
    main()
